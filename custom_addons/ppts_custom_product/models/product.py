from odoo import fields, models, api, _
from datetime import datetime
from odoo.exceptions import UserError, Warning

class ProductTemplateAttributeValue(models.Model):
    """Materialized relationship between attribute values
    and product template generated by the product.template.attribute.line"""

    _inherit = "product.template.attribute.value"

    product_tmpl_id_dup = fields.Many2one('product.template', string="Product Template")
    piece_weight = fields.Float("Piece Weight")
    uom_id = fields.Many2one("uom.uom","UOM")

    product_category = fields.Many2one(comodel_name="product.category", related="product_tmpl_id.categ_id", store=True)


    @api.onchange('product_tmpl_id')
    def onchange_product_tmpl_id(self):
        if self.product_tmpl_id:
            self.product_tmpl_id_dup = self.product_tmpl_id.id

class ProductAttributeValue(models.Model):
    _inherit = "product.attribute.value"

    def name_get(self):
        """Override because in general the name of the value is confusing if it
        is displayed without the name of the corresponding attribute.
        Eg. on product list & kanban views, on BOM form view

        However during variant set up (on the product template form) the name of
        the attribute is already on each line so there is no need to repeat it
        on every value.
        """
        if not self._context.get('show_attribute', True):
            return super(ProductAttributeValue, self).name_get()
        return [(value.id, "%s" % (value.name)) for value in self]


class ProductTemplate(models.Model):
    _inherit = 'product.template'

    container_product_ids = fields.One2many('stock.container.line', 'container_product_id', string='Container line')

    net_weight = fields.Float("Net Load(kg)", compute='_compute_net_weight')
    english_name = fields.Char('English Name')
    ecologic_name = fields.Char('Ecologic Name')
    ecologic_price = fields.Float('Ecologic Price')
    existing_barcode = fields.Char('Existing Barcode')
    product_waste_code = fields.Char('Waste Code')
    product_ecologic_code = fields.Char('Ecologic Code')
    max_stock = fields.Float('Maximum Stock')
    malus = fields.Float('Malus')
    charge_malus = fields.Float('Charge Malus')
    fraction_by_count = fields.Boolean("Fraction by Count?")
    weight_per_piece = fields.Float("Weight per Piece(kg)")
    density = fields.Float("Density")
    piece_uom_id = fields.Many2one("uom.uom", string="UOM")
    non_trie = fields.Boolean("Non-TriÃ©")

    # additional_sale = fields.Boolean(string="Additional Sale?",default=False)

    @api.onchange("product_ecologic_code")
    def onchange_product_ecologic_code(self):
        if not self.product_ecologic_code:
            self.ecologic_price = 0



    @api.depends('container_product_ids.net_weight')
    def _compute_net_weight(self):
        for rec in self:
            total_weight = 0.0
            for line in rec.container_product_ids:
                total_weight += line.net_weight
            rec.update({
                'net_weight': total_weight,
            })
    
    @api.model
    def create(self, vals):

        res = super(ProductTemplate, self).create(vals)

        # additional_sale_count = self.env['product.template'].sudo().search_count([('additional_sale','=',True)])
        # if additional_sale_count>1:
        #     raise Warning("You cannot add more than one additional sale product.")
        
        return res

class ProductProduct(models.Model):
    _inherit = 'product.product'
    
    malus = fields.Float('Malus')
    charge_malus = fields.Float('Charge Malus')
    fraction_by_count = fields.Boolean("Fraction by Count?")
    product_ecologic_code = fields.Char('Ecologic Code')


class StockContainerLine(models.Model):
    _name = 'stock.container.line'

    container_id = fields.Many2one('stock.container', string="Name")   
    net_weight = fields.Float('Net Weight(kg)')
    net_weight_unit_id = fields.Many2one('uom.uom', string="Unit")
    production_cost = fields.Float('Production Cost of Container',compute='_compute_forecasted_sales_cost')
    forecasted_sales_cost = fields.Float('Forecasted Sales Cost')
    actual_sales_cost = fields.Float('Actual Sales Cost')
    container_product_id = fields.Many2one('product.template', string='Container line Reference')

    def _compute_forecasted_sales_cost(self):
        for rec in self:
            if rec.container_id:
                rec.net_weight = rec.container_id.net_weight
                rec.production_cost = rec.container_id.forecast_sale_price
            else:
                rec.net_weight = 0.0
                rec.production_cost = 0.0